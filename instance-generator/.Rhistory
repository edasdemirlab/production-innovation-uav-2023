grid_loc <- seq(0,sqrt(mission_area), by = grid_size)
abline(h = grid_loc, v = grid_loc, col = "lightgray", lty = "dotted")
points(x = target_loc_x, y = target_loc_y, col = "black", pch = 215, cex=1)
text(coord[,2] - 10, coord[,3] - 10, labels = seq_along(0:n_targets)-1, cex = 0.8)
text(coord[1,2] - 10, coord[1,3] + 10, labels = "h", cex = 0.8)
#generate all movement types
temp_list <- c()
pair_matrix <- c()
for (d in 0:(n_nodes-1)) {
temp_list <- cbind(rep(d,(n_nodes)), 0:n_targets)
pair_matrix <- rbind(pair_matrix, temp_list)
}
#---------------------------------------------------------------------------------------------------------------
# travel duration --> d_{ij}
#Calculate Euclidean Distances
euc_distances <- round(apply(pair_matrix, 1, function(x){
pair_from <- coord[coord[,1] == x[1],2:3]
pair_to <- coord[coord[,1] == x[2],2:3]
sqrt((pair_from[1] - pair_to[1])^2 + (pair_from[2] - pair_to[2])^2)
}),4)
pair_matrix <- cbind(pair_matrix, euc_distances)
# Update distances with discounted euclidean distances. Discount rates linearly increase from 0 to discount_ratio (%30 in the paper)
discount_rates <- unlist(lapply(pair_matrix[,3],function (x) (discount_ratio/(max(pair_matrix[,3]) - min(pair_matrix[,3])))*(x - min(pair_matrix[,3]))))
discount_amounts <- (pair_matrix[,3] * discount_rates)/100
pair_matrix[,3] <- (pair_matrix[,3] - discount_amounts)
# convert distance to flight duration
pair_matrix[,3] <- pair_matrix[,3]/flight_v
#---------------------------------------------------------------------------------------------------------------
# information search and collection time s_{j,m}
search_duration_list <- sapply(1:n_revisits, function(x) search_duration*(alpha_time_reduction)^(x-1))
#Construct Y matrix:
target_df <- data.frame(target_id = target_set)
for (m in 1:n_revisits){
target_df[paste0(m)] = search_duration_list[m]
}
target_df <- melt(target_df, id.var = c('target_id') , variable.name = 'visit_id')
target_df <- target_df %>% rename("search_duration" = "value")
target_df['target_id'] = as.integer(target_df$target_id)
target_df['visit_id'] = as.integer(target_df$visit_id)
# ---------------------------------------------------------------------------------------------------
# expected Information Collection From Targets I_{jk}-> information collected from target j at kth visit
# probability that a target has information \mu_{pI_j}
prob_inf_exists <- runif(n_targets, 0.5, 1)
prob_inf_exists_permanent <- prob_inf_exists
target_info_df <- data.frame(target_id = rep(target_set, each=n_revisits), visit_id = rep(c(1:n_revisits), n_targets))
target_info_df['expected_information'] <- unlist(lapply(prob_inf_exists, function(x){
lapply(1:n_revisits, function(m){
round(x * e_s * ((1 - e_c)^(m-1) - (1-e_c)^m),4)
})
}))
target_df <- inner_join(target_df,target_info_df,by = c('target_id' = 'target_id', 'visit_id'='visit_id'))
#---------------------------------------------------------------------------------------------------------------
#Risk of being detected
lambda_j <- round(c(runif(n_targets, 0, 0.05)), 4) #number of detection per 1 hour flight
gridlines <- seq(0, x_axis_size, grid_size)
lambda_traj <- sapply(1:nrow(pair_matrix),function(s){
i <- coord[coord[,1] == pair_matrix[s,1],2:3]
j <- coord[coord[,1] == pair_matrix[s,2],2:3]
if (pair_matrix[s,1] == pair_matrix[s,2])
{
lambda_traj <- 0
}
else{
#grid lines that are cut at x axis when moving right
cuts_r_x <- gridlines[which(gridlines %in% seq(i[1], j[1]))]
cuts_r_y <- unlist(lapply(cuts_r_x, function (xx) ((xx-i[1])*(j[2]-i[2]) + i[2]*(j[1]-i[1]))/(j[1]-i[1])))
#grid lines that are cut at y axis when moving up
cuts_u_y <- gridlines[which(gridlines %in% seq(i[2],j[2]))]
cuts_u_x <- unlist(lapply(cuts_u_y, function (yy) ((j[1]-i[1])*(yy-i[2]) + i[1]*(j[2]-i[2]))/(j[2]-i[2])))
cut_points <- rbind(cbind(cuts_r_x,cuts_r_y), cbind(cuts_u_x,cuts_u_y),i)
cut_points <- cut_points[order(cut_points[,1]),]
cut_points_M <- cbind(cut_points,rbind(cut_points[2:nrow(cut_points),],j))
cut_points_dist <- apply(cut_points_M,1, function (e) sqrt((e[4]-e[2])^2 + (e[3]-e[1])^2))
cut_points_dist <- cut_points_dist-(cut_points_dist*discount_rates[s])/100 #implement discounts
cut_points_time <- cut_points_dist/flight_v
cut_points_regions <- apply(cut_points_M,1, function (c){
Cut_middle<-c((c*0.5)[1]+(c*0.5)[3],(c*0.5)[2]+(c*0.5)[4])
Cut_region<-coord_grids_matrix[which(apply(coord_grids_matrix,1,function(x){
Cut_middle[1]>=x[2] && Cut_middle[1]<=x[3] && Cut_middle[2]>=x[4] && Cut_middle[2]<=x[5]
})),1]
Cut_region[1]
})
lambda_traj <- sum(lambda_j[cut_points_regions]*cut_points_time)
}
lambda_traj
})
# add threats to the trajectory pair data frame
pair_df <- as.data.frame(pair_matrix)
colnames(pair_df) <- c('from_node', "to_node", "travel_duration")
pair_df['number_of_detections'] <- lambda_traj
lambda_df <- data.frame(target_id = target_set, number_of_detections = lambda_j)
target_df <- inner_join(target_df,lambda_df,by = c('target_id' = 'target_id'))
target_df
target_df['number_of_detections'] <- target_df$search_duration * target_df$number_of_detections
target_df
# #Load Packages
# library(Matrix)
library(dplyr)
library(reshape2)
#Set Global Parameters
options(max.print = 99999)
set.seed(594)
#Problem Parameters
n_targets <- 16  # number of targets excluding origin and destination
n_nodes <- n_targets + 1  # number of nodes including origin and destination
discount_ratio <- 30  # maximum discount in terms of %
mission_area <- 400*400
eps <- 0.1
flight_v <- 10*60  # flight speed (km per hour)
sensor_range <- 28
# search time reduction parameter
alpha_time_reduction <- 0.8
#search and collection duration
s_t <- 50/60
c_t <- 10/60
search_duration <- s_t + c_t
#restrictions
mission_late_prob <- 0.20  # the allowed risk of not completing mission on time
n_revisits <- 3  # number of allowed revisits
#effectiveness of the search and collection sensors
e_s <- (1 - exp(-(flight_v*sensor_range)/((mission_area/n_targets)))^s_t) #effectiveness of search sensor - by Xia's paper--28km is based on Global Hawk
e_c <- 0.5 #effectiveness of collection sensor - by Moskal's previous papers
# problem Sets
target_set <- 1:n_targets
node_set <- 0:n_nodes
from_set <- 0:n_targets #target set including origin excluding destination #1 is origin
to_set <- 1:n_nodes
time_step_set <- (1:((n_targets*n_revisits)+2)) #50 ((n_targets*n_revisits)+2)
allowed_revisit_set <- (1:n_revisits) # set of allowed revisits
# problem Layout
grid_size <- sqrt(mission_area)/sqrt(n_targets) #length of each grid
x_axis_size <- 400
y_axis_size <- 400
target_loc <- seq(grid_size/2, sqrt(mission_area)-grid_size/2,by = grid_size)
target_loc_x <- rep(target_loc, each = sqrt(n_targets)) # X coordinates of targets
target_loc_y <- rep(target_loc, sqrt(n_targets)) # Y coordinates of targets
coord <- cbind(0:n_nodes,c(0,target_loc_x,sqrt(mission_area)),c(0,target_loc_y, sqrt(mission_area)))
coord <- head(coord, -1)
coord_grids_matrix <- cbind(target_set,rep(seq(0,300,100),each=4),rep(seq(100,400,100),each=4),rep(seq(0,300,100),4),rep(seq(100,400,100),4))
plot(x = 0, y = 0, xlim = c(0,sqrt(mission_area)), ylim = c(0,sqrt(mission_area)), pch = 17, cex = 2, asp = 1, xlab = "",ylab = "")  #xaxt="n", yaxt="n"
grid_loc <- seq(0,sqrt(mission_area), by = grid_size)
abline(h = grid_loc, v = grid_loc, col = "lightgray", lty = "dotted")
points(x = target_loc_x, y = target_loc_y, col = "black", pch = 215, cex=1)
text(coord[,2] - 10, coord[,3] - 10, labels = seq_along(0:n_targets)-1, cex = 0.8)
text(coord[1,2] - 10, coord[1,3] + 10, labels = "h", cex = 0.8)
#generate all movement types
temp_list <- c()
pair_matrix <- c()
for (d in 0:(n_nodes-1)) {
temp_list <- cbind(rep(d,(n_nodes)), 0:n_targets)
pair_matrix <- rbind(pair_matrix, temp_list)
}
#---------------------------------------------------------------------------------------------------------------
# travel duration --> d_{ij}
#Calculate Euclidean Distances
euc_distances <- round(apply(pair_matrix, 1, function(x){
pair_from <- coord[coord[,1] == x[1],2:3]
pair_to <- coord[coord[,1] == x[2],2:3]
sqrt((pair_from[1] - pair_to[1])^2 + (pair_from[2] - pair_to[2])^2)
}),4)
pair_matrix <- cbind(pair_matrix, euc_distances)
# Update distances with discounted euclidean distances. Discount rates linearly increase from 0 to discount_ratio (%30 in the paper)
discount_rates <- unlist(lapply(pair_matrix[,3],function (x) (discount_ratio/(max(pair_matrix[,3]) - min(pair_matrix[,3])))*(x - min(pair_matrix[,3]))))
discount_amounts <- (pair_matrix[,3] * discount_rates)/100
pair_matrix[,3] <- (pair_matrix[,3] - discount_amounts)
# convert distance to flight duration
pair_matrix[,3] <- pair_matrix[,3]/flight_v
#---------------------------------------------------------------------------------------------------------------
# information search and collection time s_{j,m}
search_duration_list <- sapply(1:n_revisits, function(x) search_duration*(alpha_time_reduction)^(x-1))
#Construct Y matrix:
target_df <- data.frame(target_id = target_set)
for (m in 1:n_revisits){
target_df[paste0(m)] = search_duration_list[m]
}
target_df <- melt(target_df, id.var = c('target_id') , variable.name = 'visit_id')
target_df <- target_df %>% rename("search_duration" = "value")
target_df['target_id'] = as.integer(target_df$target_id)
target_df['visit_id'] = as.integer(target_df$visit_id)
# ---------------------------------------------------------------------------------------------------
# expected Information Collection From Targets I_{jk}-> information collected from target j at kth visit
# probability that a target has information \mu_{pI_j}
prob_inf_exists <- runif(n_targets, 0.5, 1)
prob_inf_exists_permanent <- prob_inf_exists
target_info_df <- data.frame(target_id = rep(target_set, each=n_revisits), visit_id = rep(c(1:n_revisits), n_targets))
target_info_df['expected_information'] <- unlist(lapply(prob_inf_exists, function(x){
lapply(1:n_revisits, function(m){
round(x * e_s * ((1 - e_c)^(m-1) - (1-e_c)^m),4)
})
}))
target_df <- inner_join(target_df,target_info_df,by = c('target_id' = 'target_id', 'visit_id'='visit_id'))
#---------------------------------------------------------------------------------------------------------------
#Risk of being detected
lambda_j <- round(c(runif(n_targets, 0, 0.05)), 4) #number of detection per 1 hour flight
gridlines <- seq(0, x_axis_size, grid_size)
lambda_traj <- sapply(1:nrow(pair_matrix),function(s){
i <- coord[coord[,1] == pair_matrix[s,1],2:3]
j <- coord[coord[,1] == pair_matrix[s,2],2:3]
if (pair_matrix[s,1] == pair_matrix[s,2])
{
lambda_traj <- 0
}
else{
#grid lines that are cut at x axis when moving right
cuts_r_x <- gridlines[which(gridlines %in% seq(i[1], j[1]))]
cuts_r_y <- unlist(lapply(cuts_r_x, function (xx) ((xx-i[1])*(j[2]-i[2]) + i[2]*(j[1]-i[1]))/(j[1]-i[1])))
#grid lines that are cut at y axis when moving up
cuts_u_y <- gridlines[which(gridlines %in% seq(i[2],j[2]))]
cuts_u_x <- unlist(lapply(cuts_u_y, function (yy) ((j[1]-i[1])*(yy-i[2]) + i[1]*(j[2]-i[2]))/(j[2]-i[2])))
cut_points <- rbind(cbind(cuts_r_x,cuts_r_y), cbind(cuts_u_x,cuts_u_y),i)
cut_points <- cut_points[order(cut_points[,1]),]
cut_points_M <- cbind(cut_points,rbind(cut_points[2:nrow(cut_points),],j))
cut_points_dist <- apply(cut_points_M,1, function (e) sqrt((e[4]-e[2])^2 + (e[3]-e[1])^2))
cut_points_dist <- cut_points_dist-(cut_points_dist*discount_rates[s])/100 #implement discounts
cut_points_time <- cut_points_dist/flight_v
cut_points_regions <- apply(cut_points_M,1, function (c){
Cut_middle<-c((c*0.5)[1]+(c*0.5)[3],(c*0.5)[2]+(c*0.5)[4])
Cut_region<-coord_grids_matrix[which(apply(coord_grids_matrix,1,function(x){
Cut_middle[1]>=x[2] && Cut_middle[1]<=x[3] && Cut_middle[2]>=x[4] && Cut_middle[2]<=x[5]
})),1]
Cut_region[1]
})
lambda_traj <- sum(lambda_j[cut_points_regions]*cut_points_time)
}
lambda_traj
})
# add threats to the trajectory pair data frame
pair_df <- as.data.frame(pair_matrix)
colnames(pair_df) <- c('from_node', "to_node", "travel_duration")
pair_df['number_of_detections'] <- lambda_traj
lambda_df <- data.frame(target_id = target_set, number_of_detections = lambda_j)
target_df <- inner_join(target_df,lambda_df,by = c('target_id' = 'target_id'))
target_df['number_of_detections'] <- target_df$search_duration * target_df$number_of_detections
# #Load Packages
# library(Matrix)
library(dplyr)
library(reshape2)
#Set Global Parameters
options(max.print = 99999)
set.seed(594)
#Problem Parameters
n_targets <- 16  # number of targets excluding origin and destination
n_nodes <- n_targets + 1  # number of nodes including origin and destination
discount_ratio <- 30  # maximum discount in terms of %
mission_area <- 400*400
eps <- 0.1
flight_v <- 10*60  # flight speed (km per hour)
sensor_range <- 28
# search time reduction parameter
alpha_time_reduction <- 0.8
#search and collection duration
s_t <- 50/60
c_t <- 10/60
search_duration <- s_t + c_t
#restrictions
mission_late_prob <- 0.20  # the allowed risk of not completing mission on time
n_revisits <- 3  # number of allowed revisits
#effectiveness of the search and collection sensors
e_s <- (1 - exp(-(flight_v*sensor_range)/((mission_area/n_targets)))^s_t) #effectiveness of search sensor - by Xia's paper--28km is based on Global Hawk
e_c <- 0.5 #effectiveness of collection sensor - by Moskal's previous papers
# problem Sets
target_set <- 1:n_targets
node_set <- 0:n_nodes
from_set <- 0:n_targets #target set including origin excluding destination #1 is origin
to_set <- 1:n_nodes
time_step_set <- (1:((n_targets*n_revisits)+2)) #50 ((n_targets*n_revisits)+2)
allowed_revisit_set <- (1:n_revisits) # set of allowed revisits
# problem Layout
grid_size <- sqrt(mission_area)/sqrt(n_targets) #length of each grid
x_axis_size <- 400
y_axis_size <- 400
target_loc <- seq(grid_size/2, sqrt(mission_area)-grid_size/2,by = grid_size)
target_loc_x <- rep(target_loc, each = sqrt(n_targets)) # X coordinates of targets
target_loc_y <- rep(target_loc, sqrt(n_targets)) # Y coordinates of targets
coord <- cbind(0:n_nodes,c(0,target_loc_x,sqrt(mission_area)),c(0,target_loc_y, sqrt(mission_area)))
coord <- head(coord, -1)
coord_grids_matrix <- cbind(target_set,rep(seq(0,300,100),each=4),rep(seq(100,400,100),each=4),rep(seq(0,300,100),4),rep(seq(100,400,100),4))
plot(x = 0, y = 0, xlim = c(0,sqrt(mission_area)), ylim = c(0,sqrt(mission_area)), pch = 17, cex = 2, asp = 1, xlab = "",ylab = "")  #xaxt="n", yaxt="n"
grid_loc <- seq(0,sqrt(mission_area), by = grid_size)
abline(h = grid_loc, v = grid_loc, col = "lightgray", lty = "dotted")
points(x = target_loc_x, y = target_loc_y, col = "black", pch = 215, cex=1)
text(coord[,2] - 10, coord[,3] - 10, labels = seq_along(0:n_targets)-1, cex = 0.8)
text(coord[1,2] - 10, coord[1,3] + 10, labels = "h", cex = 0.8)
#generate all movement types
temp_list <- c()
pair_matrix <- c()
for (d in 0:(n_nodes-1)) {
temp_list <- cbind(rep(d,(n_nodes)), 0:n_targets)
pair_matrix <- rbind(pair_matrix, temp_list)
}
#---------------------------------------------------------------------------------------------------------------
# travel duration --> d_{ij}
#Calculate Euclidean Distances
euc_distances <- round(apply(pair_matrix, 1, function(x){
pair_from <- coord[coord[,1] == x[1],2:3]
pair_to <- coord[coord[,1] == x[2],2:3]
sqrt((pair_from[1] - pair_to[1])^2 + (pair_from[2] - pair_to[2])^2)
}),4)
pair_matrix <- cbind(pair_matrix, euc_distances)
# Update distances with discounted euclidean distances. Discount rates linearly increase from 0 to discount_ratio (%30 in the paper)
discount_rates <- unlist(lapply(pair_matrix[,3],function (x) (discount_ratio/(max(pair_matrix[,3]) - min(pair_matrix[,3])))*(x - min(pair_matrix[,3]))))
discount_amounts <- (pair_matrix[,3] * discount_rates)/100
pair_matrix[,3] <- (pair_matrix[,3] - discount_amounts)
# convert distance to flight duration
pair_matrix[,3] <- pair_matrix[,3]/flight_v
#---------------------------------------------------------------------------------------------------------------
# information search and collection time s_{j,m}
search_duration_list <- sapply(1:n_revisits, function(x) search_duration*(alpha_time_reduction)^(x-1))
#Construct Y matrix:
target_df <- data.frame(target_id = target_set)
for (m in 1:n_revisits){
target_df[paste0(m)] = search_duration_list[m]
}
target_df <- melt(target_df, id.var = c('target_id') , variable.name = 'visit_id')
target_df <- target_df %>% rename("search_duration" = "value")
target_df['target_id'] = as.integer(target_df$target_id)
target_df['visit_id'] = as.integer(target_df$visit_id)
# ---------------------------------------------------------------------------------------------------
# expected Information Collection From Targets I_{jk}-> information collected from target j at kth visit
# probability that a target has information \mu_{pI_j}
prob_inf_exists <- runif(n_targets, 0.5, 1)
prob_inf_exists_permanent <- prob_inf_exists
target_info_df <- data.frame(target_id = rep(target_set, each=n_revisits), visit_id = rep(c(1:n_revisits), n_targets))
target_info_df['expected_information'] <- unlist(lapply(prob_inf_exists, function(x){
lapply(1:n_revisits, function(m){
round(x * e_s * ((1 - e_c)^(m-1) - (1-e_c)^m),4)
})
}))
target_df <- inner_join(target_df,target_info_df,by = c('target_id' = 'target_id', 'visit_id'='visit_id'))
#---------------------------------------------------------------------------------------------------------------
#Risk of being detected
lambda_j <- round(c(runif(n_targets, 0, 0.05)), 4) #number of detection per 1 hour flight
gridlines <- seq(0, x_axis_size, grid_size)
lambda_traj <- sapply(1:nrow(pair_matrix),function(s){
i <- coord[coord[,1] == pair_matrix[s,1],2:3]
j <- coord[coord[,1] == pair_matrix[s,2],2:3]
if (pair_matrix[s,1] == pair_matrix[s,2])
{
lambda_traj <- 0
}
else{
#grid lines that are cut at x axis when moving right
cuts_r_x <- gridlines[which(gridlines %in% seq(i[1], j[1]))]
cuts_r_y <- unlist(lapply(cuts_r_x, function (xx) ((xx-i[1])*(j[2]-i[2]) + i[2]*(j[1]-i[1]))/(j[1]-i[1])))
#grid lines that are cut at y axis when moving up
cuts_u_y <- gridlines[which(gridlines %in% seq(i[2],j[2]))]
cuts_u_x <- unlist(lapply(cuts_u_y, function (yy) ((j[1]-i[1])*(yy-i[2]) + i[1]*(j[2]-i[2]))/(j[2]-i[2])))
cut_points <- rbind(cbind(cuts_r_x,cuts_r_y), cbind(cuts_u_x,cuts_u_y),i)
cut_points <- cut_points[order(cut_points[,1]),]
cut_points_M <- cbind(cut_points,rbind(cut_points[2:nrow(cut_points),],j))
cut_points_dist <- apply(cut_points_M,1, function (e) sqrt((e[4]-e[2])^2 + (e[3]-e[1])^2))
cut_points_dist <- cut_points_dist-(cut_points_dist*discount_rates[s])/100 #implement discounts
cut_points_time <- cut_points_dist/flight_v
cut_points_regions <- apply(cut_points_M,1, function (c){
Cut_middle<-c((c*0.5)[1]+(c*0.5)[3],(c*0.5)[2]+(c*0.5)[4])
Cut_region<-coord_grids_matrix[which(apply(coord_grids_matrix,1,function(x){
Cut_middle[1]>=x[2] && Cut_middle[1]<=x[3] && Cut_middle[2]>=x[4] && Cut_middle[2]<=x[5]
})),1]
Cut_region[1]
})
lambda_traj <- sum(lambda_j[cut_points_regions]*cut_points_time)
}
lambda_traj
})
# add threats to the trajectory pair data frame
trajectory_df <- as.data.frame(pair_matrix)
colnames(trajectory_df) <- c('from_node', "to_node", "travel_duration")
trajectory_df['number_of_detections'] <- lambda_traj
lambda_df <- data.frame(target_id = target_set, number_of_detections = lambda_j)
target_df <- inner_join(target_df,lambda_df,by = c('target_id' = 'target_id'))
target_df['number_of_detections'] <- target_df$search_duration * target_df$number_of_detections
trajectory_df
# #Load Packages
# library(Matrix)
library(dplyr)
library(reshape2)
#Set Global Parameters
options(max.print = 99999)
set.seed(594)
#Problem Parameters
n_targets <- 16  # number of targets excluding origin and destination
n_nodes <- n_targets + 1  # number of nodes including origin and destination
discount_ratio <- 30  # maximum discount in terms of %
mission_area <- 400*400
eps <- 0.1
flight_v <- 10*60  # flight speed (km per hour)
sensor_range <- 28
# search time reduction parameter
alpha_time_reduction <- 0.8
#search and collection duration
s_t <- 50/60
c_t <- 10/60
search_duration <- s_t + c_t
#restrictions
mission_late_prob <- 0.20  # the allowed risk of not completing mission on time
n_revisits <- 3  # number of allowed revisits
#effectiveness of the search and collection sensors
e_s <- (1 - exp(-(flight_v*sensor_range)/((mission_area/n_targets)))^s_t) #effectiveness of search sensor - by Xia's paper--28km is based on Global Hawk
e_c <- 0.5 #effectiveness of collection sensor - by Moskal's previous papers
# problem Sets
target_set <- 1:n_targets
node_set <- 0:n_nodes
from_set <- 0:n_targets #target set including origin excluding destination #1 is origin
to_set <- 1:n_nodes
time_step_set <- (1:((n_targets*n_revisits)+2)) #50 ((n_targets*n_revisits)+2)
allowed_revisit_set <- (1:n_revisits) # set of allowed revisits
# problem Layout
grid_size <- sqrt(mission_area)/sqrt(n_targets) #length of each grid
x_axis_size <- 400
y_axis_size <- 400
target_loc <- seq(grid_size/2, sqrt(mission_area)-grid_size/2,by = grid_size)
target_loc_x <- rep(target_loc, each = sqrt(n_targets)) # X coordinates of targets
target_loc_y <- rep(target_loc, sqrt(n_targets)) # Y coordinates of targets
coord <- cbind(0:n_nodes,c(0,target_loc_x,sqrt(mission_area)),c(0,target_loc_y, sqrt(mission_area)))
coord <- head(coord, -1)
coord_grids_matrix <- cbind(target_set,rep(seq(0,300,100),each=4),rep(seq(100,400,100),each=4),rep(seq(0,300,100),4),rep(seq(100,400,100),4))
plot(x = 0, y = 0, xlim = c(0,sqrt(mission_area)), ylim = c(0,sqrt(mission_area)), pch = 17, cex = 2, asp = 1, xlab = "",ylab = "")  #xaxt="n", yaxt="n"
grid_loc <- seq(0,sqrt(mission_area), by = grid_size)
abline(h = grid_loc, v = grid_loc, col = "lightgray", lty = "dotted")
points(x = target_loc_x, y = target_loc_y, col = "black", pch = 215, cex=1)
text(coord[,2] - 10, coord[,3] - 10, labels = seq_along(0:n_targets)-1, cex = 0.8)
text(coord[1,2] - 10, coord[1,3] + 10, labels = "h", cex = 0.8)
#generate all movement types
temp_list <- c()
pair_matrix <- c()
for (d in 0:(n_nodes-1)) {
temp_list <- cbind(rep(d,(n_nodes)), 0:n_targets)
pair_matrix <- rbind(pair_matrix, temp_list)
}
#---------------------------------------------------------------------------------------------------------------
# travel duration --> d_{ij}
#Calculate Euclidean Distances
euc_distances <- apply(pair_matrix, 1, function(x){
pair_from <- coord[coord[,1] == x[1],2:3]
pair_to <- coord[coord[,1] == x[2],2:3]
sqrt((pair_from[1] - pair_to[1])^2 + (pair_from[2] - pair_to[2])^2)
})
pair_matrix <- cbind(pair_matrix, euc_distances)
# Update distances with discounted euclidean distances. Discount rates linearly increase from 0 to discount_ratio (%30 in the paper)
discount_rates <- unlist(lapply(pair_matrix[,3],function (x) (discount_ratio/(max(pair_matrix[,3]) - min(pair_matrix[,3])))*(x - min(pair_matrix[,3]))))
discount_amounts <- (pair_matrix[,3] * discount_rates)/100
pair_matrix[,3] <- (pair_matrix[,3] - discount_amounts)
# convert distance to flight duration
pair_matrix[,3] <- round(pair_matrix[,3]/flight_v,4)
#---------------------------------------------------------------------------------------------------------------
# information search and collection time s_{j,m}
search_duration_list <- sapply(1:n_revisits, function(x) search_duration*(alpha_time_reduction)^(x-1))
#Construct Y matrix:
target_df <- data.frame(target_id = target_set)
for (m in 1:n_revisits){
target_df[paste0(m)] = search_duration_list[m]
}
target_df <- melt(target_df, id.var = c('target_id') , variable.name = 'visit_id')
target_df <- target_df %>% rename("search_duration" = "value")
target_df['target_id'] = as.integer(target_df$target_id)
target_df['visit_id'] = as.integer(target_df$visit_id)
# ---------------------------------------------------------------------------------------------------
# expected Information Collection From Targets I_{jk}-> information collected from target j at kth visit
# probability that a target has information \mu_{pI_j}
prob_inf_exists <- runif(n_targets, 0.5, 1)
prob_inf_exists_permanent <- prob_inf_exists
target_info_df <- data.frame(target_id = rep(target_set, each=n_revisits), visit_id = rep(c(1:n_revisits), n_targets))
target_info_df['expected_information'] <- unlist(lapply(prob_inf_exists, function(x){
lapply(1:n_revisits, function(m){
round(x * e_s * ((1 - e_c)^(m-1) - (1-e_c)^m),4)
})
}))
target_df <- inner_join(target_df,target_info_df,by = c('target_id' = 'target_id', 'visit_id'='visit_id'))
#---------------------------------------------------------------------------------------------------------------
#Risk of being detected
lambda_j <- round(c(runif(n_targets, 0, 0.05)), 4) #number of detection per 1 hour flight
gridlines <- seq(0, x_axis_size, grid_size)
lambda_traj <- sapply(1:nrow(pair_matrix),function(s){
i <- coord[coord[,1] == pair_matrix[s,1],2:3]
j <- coord[coord[,1] == pair_matrix[s,2],2:3]
if (pair_matrix[s,1] == pair_matrix[s,2])
{
lambda_traj <- 0
}
else{
#grid lines that are cut at x axis when moving right
cuts_r_x <- gridlines[which(gridlines %in% seq(i[1], j[1]))]
cuts_r_y <- unlist(lapply(cuts_r_x, function (xx) ((xx-i[1])*(j[2]-i[2]) + i[2]*(j[1]-i[1]))/(j[1]-i[1])))
#grid lines that are cut at y axis when moving up
cuts_u_y <- gridlines[which(gridlines %in% seq(i[2],j[2]))]
cuts_u_x <- unlist(lapply(cuts_u_y, function (yy) ((j[1]-i[1])*(yy-i[2]) + i[1]*(j[2]-i[2]))/(j[2]-i[2])))
cut_points <- rbind(cbind(cuts_r_x,cuts_r_y), cbind(cuts_u_x,cuts_u_y),i)
cut_points <- cut_points[order(cut_points[,1]),]
cut_points_M <- cbind(cut_points,rbind(cut_points[2:nrow(cut_points),],j))
cut_points_dist <- apply(cut_points_M,1, function (e) sqrt((e[4]-e[2])^2 + (e[3]-e[1])^2))
cut_points_dist <- cut_points_dist-(cut_points_dist*discount_rates[s])/100 #implement discounts
cut_points_time <- cut_points_dist/flight_v
cut_points_regions <- apply(cut_points_M,1, function (c){
Cut_middle<-c((c*0.5)[1]+(c*0.5)[3],(c*0.5)[2]+(c*0.5)[4])
Cut_region<-coord_grids_matrix[which(apply(coord_grids_matrix,1,function(x){
Cut_middle[1]>=x[2] && Cut_middle[1]<=x[3] && Cut_middle[2]>=x[4] && Cut_middle[2]<=x[5]
})),1]
Cut_region[1]
})
lambda_traj <- sum(lambda_j[cut_points_regions]*cut_points_time)
}
lambda_traj
})
# add threats to the trajectory pair data frame
trajectory_df <- as.data.frame(pair_matrix)
colnames(trajectory_df) <- c('from_node', "to_node", "travel_duration")
trajectory_df['number_of_detections'] <- lambda_traj
lambda_df <- data.frame(target_id = target_set, number_of_detections = lambda_j)
target_df <- inner_join(target_df,lambda_df,by = c('target_id' = 'target_id'))
target_df['number_of_detections'] <- target_df$search_duration * target_df$number_of_detections
trajectory_df
target_df
